// Minimal idb-like shim for this app's needs (openDB, get/put/delete/getAll, transaction)
// Not a full replacement for https://github.com/jakearchibald/idb, but enough for our usage.
;(function(){
  if (window.idb && typeof window.idb.openDB === 'function') return; // already present

  function wrapDB(db){
    function tx(storeName, mode){
      const t = db.transaction(storeName, mode);
      const store = t.objectStore(storeName);
      return {
        store: wrapStore(store),
        done: new Promise((res, rej)=>{ t.oncomplete=()=>res(); t.onerror=()=>rej(t.error); t.onabort=()=>rej(t.error||new Error('tx aborted')); })
      };
    }
    function wrapStore(store){
      return {
        get(key){ return reqPromise(store.get(key)); },
        put(val, key){ return reqPromise(key!==undefined ? store.put(val, key) : store.put(val)); },
        delete(key){ return reqPromise(store.delete(key)); },
        getAll(){ return store.getAll ? reqPromise(store.getAll()) : getAllCursor(store); },
        clear(){ return reqPromise(store.clear()); }
      };
    }
    function reqPromise(req){
      return new Promise((res, rej)=>{ req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); });
    }
    function getAllCursor(store){
      return new Promise((resolve, reject)=>{
        const results=[]; const req=store.openCursor();
        req.onsuccess=()=>{ const cursor=req.result; if(cursor){ results.push(cursor.value); cursor.continue(); } else resolve(results); };
        req.onerror=()=>reject(req.error);
      });
    }
    return {
      get(store, key){ return tx(store,'readonly').store.get(key); },
      put(store, val, key){ return tx(store,'readwrite').store.put(val, key); },
      delete(store, key){ return tx(store,'readwrite').store.delete(key); },
      getAll(store){ return tx(store,'readonly').store.getAll(); },
      transaction(storeName, mode){ return tx(storeName, mode); },
      get objectStoreNames(){ return db.objectStoreNames; }
    };
  }

  window.idb = {
    openDB(name, version, opts){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(name, version);
        req.onupgradeneeded = (e)=>{
          try{ opts && typeof opts.upgrade==='function' && opts.upgrade(req.result, e.oldVersion, e.newVersion, req.transaction); }
          catch(err){ console.error('idb shim upgrade error', err); throw err; }
        };
        req.onsuccess = ()=> resolve(wrapDB(req.result));
        req.onerror = ()=> reject(req.error);
      });
    }
  };
})();
